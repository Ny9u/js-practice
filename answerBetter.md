## 对于一些简单的问题,我们应该思考怎么回答才能更好更有深度,而不是三言两语就了事

### 对闭包的理解

> 1. 对闭包概念的解释: 闭包是指函数与其词法环境的组合
> 2. 闭包是如何形成: 内层函数访问了外部函数的作用域变量
> 3. 闭包有什么作用: 实现数据隐藏和封装,实现高阶函数(返回函数的函数)
> 4. 闭包会造成什么问题: 内存泄露,性能问题

### 对原型链的理解

> 1. 对原型链概念的解释: 每个对象都有一个__proto__属性,指向另一个对象,这个对象就是其原型对象,而这个原型对象可以用同样的方式去继续访问,这样的一系列对象链接构成了原型链
> 2. 原型链是如何构建的: 假设我们通过Person类创建了一个新对象,那么新对象的原型对象就会自动绑定为Person的prototype;而原型对象又可以是另一个对象的实例,这样就形成了多层继承的关系
> 3. 原型链的作用: 实现属性和方法的共享,实现继承

### 对promise的理解

> 1. 对promise概念进行解释: promise是一种实现异步编程的方式,每一个promise对象表示一个异步操作的状态,promise对象有三种状态(pending,fulfilled,rejected),状态之间可以进行转换
> 2. 对promise的特性进行说明:链式调用,then,catch返回一个新的promise
> 3. 对promise的方法进行介绍: then(fulfilled时的回调),catch(rejected时的回调),finally(promise结束时的回调);还有一系列静态方法(all,race,allsetted)

### 讲一下事件循环

> 1. 对事件循环的概念和一些名词进行解释: 事件循环是单线程JS处理异步操作的机制,同步任务异步任务解释,异步任务细分微任务和宏任务,这两个分别任务举例
> 2. 对事件循环的过程进行说明: 先同后异,先微后宏,从执行栈中读取任务,判断是同步还是异步,同步怎么处理,异步怎么处理(注册回调函数放入任务队列,当执行栈为空时读取任务队列的函数放入主线程处理)

### 讲一下跨域

> 1. 首先对跨域的概念进行解释: 跨域是指一个域名网页请求另一个域名的资源,而跨域会受到同源策略的限制(协议域名端口号都相同方为同源,不同源之间不能访问)
> 2. 产生跨域的场景: 前后端分离项目请求api,iframe嵌入网页
> 3. 如何解决跨域问题: CORS(跨域资源共享),JSONP,代理服务器

### 对HTTPS的理解

> 1. 对HTTPS的概念进行解释: HTTP是指超文本传输协议,而S则代表安全,HTTPS是一种应用层协议,经常用于网络主体之间的数据传输
> 2. 与HTTP的区别: 安全,多了一个SSL/TLS层,数字证书
> 3. 扩展: HTTPS建立连接过程,使用了什么加密算法,摘要算法

### 深拷贝浅拷贝

> 1. 深拷贝和浅拷贝的区别: 拷贝层级,内存处理
> 2. 拷贝层级:浅拷贝只拷贝第一层,遇到引用类型时返回其引用
> 3. 内存处理:浅拷贝是引用,执行同一片内存;深拷贝是新开辟内存空间
> 4. 实现方法: Object.assign()(浅拷贝) , 展开运算符(浅拷贝) ,转json字符串再转对象(深拷贝,但无法处理引用类型),递归拷贝(深拷贝),第三方库lodash(深拷贝)

### Vue2和Vue3

> 1. 响应式方面: vue2使用的是defineproperty对某一个属性进行响应式处理,vue3用的是proxy代理整个对象
> 2. 生命周期方面: destroy替换成了unMounted
> 3. 代码编写方面: 选项式api和组合式(函数式)api
> 4. ts支持/性能/树摇支持

### 防抖节流

> 1. 防抖的核心思想是事件触发后如果一段时间内没有再触发则执行回调函数,通过定时器实现(应用场景用户输入框输入)
> 2. 节流的核心思想是一定时间段内只允许执行一次,通过时间戳实现(应用场景需要限制执行频率,例如滚动事件)

### computed和watch

> 1. computed: 计算属性,基于其他数据计算出一个值,有延迟更新的特性,只有在依赖的数据发生变化时才会进行更新,否则读取的都是缓存值
> 2. watch: 监听数据的变化,并在变化时执行特定的逻辑处理(回调函数)

### Vue组件传值

> 1. props/emit
> 2. 事件总线
> 3. provide/inject
> 4. vuex

### v-if和v-show

> 1. v-if: 会重新创建或销毁DOM元素
> 2. v-show: 只是通过样式隐藏,引出CSS隐藏元素的3种方式
